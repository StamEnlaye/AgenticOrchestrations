import json
import sys
import ollama
import re

from typing import Union

decompSys = """\
You are the decomposition module for a construction-contract Q&A pipeline.

Your single task: read ONE user prompt and sort every literal fragment of text into
exactly four arrays inside a single JSON object.

Arrays (include all four even when empty):

1. "context": statements describing background, scenario, or assumptions that
                  appear verbatim in the user text.
2. "queries": each explicit QUESTION rewritten for clarity while preserving
                  original technical nouns (“anchor terms”). Do not split a question
                  unless the user clearly asks more than one.
3. "directives" :instructions about format, language, or style
                  (e.g. “list the clauses”, “translate to Spanish”, “give a table”).
4. "noise" : greetings, apologies, filler words that carry no meaning.

Output rules (strict):

• Rewrite vague or subjective questions into clear, specific language using the user's original terms.
• Never invent, paraphrase, or add facts.  
• Keep anchor terms exactly (change order or casing only if needed for grammar).  
• Do not carry examples from earlier turns.  
• Return **valid JSON on one line** - no markdown, comments, or trailing commas.  
• Use straight double-quotes only.  
• Keys must appear in the order shown above.

Schema (always):

{"context":[],"queries":[],"directives":[],"noise":[]}

"""
keywordSys = """\
You are a helpful assistant. You will be given a user query that will be used as a search probe to retrieve information from contracts related to construction. 
Task: for each query, return a valid JSON that extracts 5 keywords from the query that will be the most helpful to search for during the retrieval process. 
If there are less than 5 keywords in the query, generate the remaining keyword(s) based on the fact that 
key words you are generating will be used to create subqueries that will be used as search probes for the retrieval process.
Output format(exactly one line, valid JSON, no extra text, no markdown fences):
{ "prompt": "What are the liquidated damages?", "keywords": ["liquidated","damages","penalty","compensation","calculation"]}

"""
subquerySys = """
You are an inquisitive assistant. You will be given:
  1. An original user query about a construction contract.
  2. Five associated keywords (either extracted from the query or chosen to guide retrieval).

Your task is to decompose the original query into a sequence of investigative subqueries. These will act as “chain-of-thought” prompts for a RAG answer synthesizer, helping it explore every angle before composing the final answer.

Each subquery must:
  - Be phrased as an open, investigative question (e.g. “What types of liquidated damages exist?” rather than “Extract liquidated damages”).
  - Contain at least one of the provided keywords.
  - Represent a distinct piece of information needed to answer the overall query.
  - Be clear and concise, without redundancy.
  - Together cover all facets of the original query so the synthesizer can build a complete, accurate response.

Output only the numbered list of subqueries (no extra text, no markdown fences), for example:

1. What types of liquidated damages are there?
2. Is there a cap on liability for delay damages?
3. How are delay damages typically calculated?
...and so on until all aspects are covered.
"""
missingInfoSys = """
You are an evaluation assistant. You will be given:
1. The original user query.
2. The answer generated by the construction chatbot for that query.

Your task is to determine whether the generated answer fully satisfies the user’s query.

Instructions:
- If the answer is complete and accurate, respond with exactly:
Assessment: Sufficient

- If any part of the query is missing, unclear, or unsupported, respond with a numbered list of investigative follow-up subquestions. Each subquestion should:
  - Address one specific missing element
  - Be concise, precise, and non-redundant

Output rules:
- Output must be either:
    a) A single line: Assessment: Sufficient  
    OR  
    b) A numbered list of subquestions (no bullet points, no explanations)
- Do not include any extra text, commentary, formatting, or whitespace.
- Do not say things like “Here is the list” or “The following questions…”
"""
missingInfoSys = """
You are an evaluation assistant. You will be given:
1. The original user query.
2. The answer generated by the construction chatbot for that query.

Your task is to determine whether the generated answer fully satisfies the user's query.

Instructions:
- If the answer is complete and accurate, respond with exactly:
Assessment: Sufficient

- If any part of the query is missing, unclear, or unsupported, respond with a numbered list of investigative follow-up subquestions. Each subquestion should:
  - Address one specific missing element
  - Be concise, precise, and non-redundant

Output rules:
- Output must be either:
    a) A single line: Assessment: Sufficient  
    OR  
    b) A numbered list of subquestions (no bullet points, no explanations)
- Do not include any extra text, commentary, formatting, or whitespace.
- Do not say things like “Here is the list” or “The following questions…”
"""
missingInfoFewShot = [
{"role": "user", "content": "{ \"query\": \"What is the retention percentage and when is it released?\", \"generatedResponse\": \"The contract specifies a 5% retention.\" }"},
{"role": "assistant", "content": "1. When is the retention amount released?\n2. Are there conditions that must be met before the retention is paid?"},

{"role": "user", "content": "{ \"query\": \"Who is responsible for submitting payment applications?\", \"generatedResponse\": \"The contractor is responsible for submitting payment applications.\" }"},
{"role": "assistant", "content": "Assessment: Sufficient"},

{"role": "user", "content": "{ \"query\": \"What are the insurance requirements and who provides proof?\", \"generatedResponse\": \"Proof of insurance must be provided.\" }"},
{"role": "assistant", "content": "1. What specific types of insurance are required?\n2. Who is responsible for providing proof of each insurance type?"},

{"role": "user", "content": "{ \"query\": \"Define substantial completion and state who certifies it.\", \"generatedResponse\": \"Substantial completion means the project can be used for its intended purpose.\" }"},
{"role": "assistant", "content": "1. Who certifies substantial completion?"}
]

fewshotDecomp = [
    # ── EXAMPLE 1 : combined context + multi-question ────────────────────────────
    {
        "role": "user",
        "content": (
            "I'm considering a new build. I'm debating whether to use steel or masonry frames. "
            "What are the cost differences, design duration, and which should I choose? "
            "And please summarize the results in a table."
        ),
    },
    {
        "role": "assistant",
        "content": (
            "{\n"
            '  "context":    ["I am considering a new building and choosing between steel and masonry frames."],\n'
            '  "queries":    [\n'
            '    "What is the cost difference between steel and masonry structural frames?",\n'
            '    "What is the typical design duration for steel versus masonry frames?",\n'
            '    "Which frame type—steel or masonry—should be chosen for this new build?"\n'
            "  ],\n"
            '  "directives": ["Summarize the results in a table."],\n'
            '  "noise":      []\n'
            "}"
        ),
    },
    # ── EXAMPLE 2 : simple calculation (no context) ──────────────────────────────
    {
        "role": "user",
        "content": "What's 30% of 500 000?",
    },
    {
        "role": "assistant",
        "content": (
            "{\n"
            '  "context":    [],\n'
            '  "queries":    ["What is 30% of 500 000?"],\n'
            '  "directives": [],\n'
            '  "noise":      []\n'
            "}"
        ),
    },
    # ── EXAMPLE 3 : reformatting request only ────────────────────────────────────
    {
        "role": "user",
        "content": "Give me the output in a markdown table.",
    },
    {
        "role": "assistant",
        "content": (
            "{\n"
            '  "context":    [],\n'
            '  "queries":    [],\n'
            '  "directives": ["Give me the output in a markdown table."],\n'
            '  "noise":      []\n'
            "}"
        ),
    },
    # ── EXAMPLE 4 : follow-up clarification (no new context) ─────────────────────
    {
        "role": "user",
        "content": "Please give me all of the information about schedule management plan",
    },
    {
        "role": "assistant",
        "content": (
            "{\n"
            '  "context":    [],\n'
            '  "queries":    ["Give information about schedule management plan"],\n'
            '  "directives": [],\n'
            '  "noise":      ["Please"]\n'
            "}"
        ),
    },
    # ── EXAMPLE 5 : greeting + simple question (noise captured) ──────────────────
    {
        "role": "user",
        "content": "Hi there! What are liquidated damages?",
    },
    {
        "role": "assistant",
        "content": (
            "{\n"
            '  "context":    [],\n'
            '  "queries":    ["What are liquidated damages?"],\n'
            '  "directives": [],\n'
            '  "noise":      ["Hi there!"]\n'
            "}"
        ),
    },
]
fewshotKeyword = [
    {
        "role": "user",
        "content": "Who approves a change order over $50,000?"
    },
    {
        "role": "assistant",
        "content": '{"prompt":"Who approves a change order over $50,000?","keywords":["change order","approval","$50,000","authorization","threshold"]}'
    },
    {"role": "user", "content": "What are the liquidated damages?"},
    {
        "role": "assistant",
        "content": '{ "prompt": "What are the liquidated damages?", "keywords": ["liquidated","damages","penalty","compensation","calculation"]}',
    },
]
fewshotSubquery = [
    # Example 1: liquidated damages → just the essential investigative probes
    {
        "role": "user",
        "content": '{ "prompt": "What are the liquidated damages?", "keywords": ["liquidated","damages","penalty","compensation","calculation"] }'
    },
    {
        "role": "assistant",
        "content":
            "1. What types of liquidated damages are defined in the contract?\n"
            "2. Is there a cap or maximum on the liquidated damages penalty?\n"
            "3. How is the compensation amount calculated for delays?\n"
            "4. Are there any illustrative examples or formulas for calculating those damages?"
    },

    # Example 2: substantial completion → minimal focused follow-ups
    {
        "role": "user",
        "content": '{ "prompt": "Define substantial completion in this contract.", "keywords": ["substantial completion","definition","completion date","certificate","milestone"] }'
    },
    {
        "role": "assistant",
        "content":
            "1. How does the contract define the milestone for substantial completion?\n"
            "2. What certificate or documentation is required to confirm that completion?"
    },

    # Example 3: change order approval → thorough investigative probes
    {
        "role": "user",
        "content": '{ "prompt": "Who approves a change order over $50,000?", "keywords": ["change order","approval","$50,000","authorization","threshold"] }'
    },
    {
        "role": "assistant",
        "content":
            "1. Which clause sets the authorization threshold for change orders?\n"
            "2. Who is the designated approver for any change order exceeding $50,000?\n"
            "3. What title or role holds that approval authority?\n"
            "4. Are there procedural steps or reviews required before approval?\n"
            "5. What documentation or signatures must accompany the approved change order?"
    }
]
altSubquerySys = """
You are a seasoned contracts investigator with deep experience in construction projects.

You will receive a single user query about a construction contract. Your job is to brainstorm the critical follow-up questions—like a specialist team (project manager, risk analyst, legal counsel) peeling back each layer to reveal hidden obligations and risks.

Guidelines for each subquery:
- Focus on identifying thresholds, triggers, exceptions, or financial/legal consequences.
- Address different perspectives (e.g. contractor’s risk, owner’s liability, insurance impacts).
- Use clear, open-ended phrasing (“What happens if…?”, “Under which conditions…?”).
- Only include as many questions as needed—don’t default to a set number.
- Avoid general textbook definitions; ground each question in real contractual practice.

Output exactly a numbered list of subqueries, nothing else.
"""

directSubquerySys = """
You are a construction-savvy assistant helping to investigate contract-related prompts.

You will be given a single rewritten user query about a construction contract. Your task is to generate a list of investigative subquestions that a project manager, contract administrator, or legal reviewer would naturally ask to fully understand and answer the query.

Each subquery must:
- Be construction-specific, going beyond general definitions.
- Reflect real-world concerns such as thresholds, conditions, exceptions, or financial/legal implications.
- Be distinct and non-redundant.
- Vary in number depending on what the original question logically invites — do not always return five.

Only return a numbered list of subqueries. No markdown, extra text, or formatting wrappers.
"""
fewshotDirectSubquery = [
    {
        "role": "user",
        "content": "What are the liquidated damages under the contract?"
    },
    {
        "role": "assistant",
        "content": (
            "1. What specific delays trigger liquidated damages under this contract?\n"
            "2. How is the per-day rate for delay damages calculated or justified?\n"
            "3. Are there any grace periods or exclusions that prevent liquidated damages from being applied?\n"
            "4. Does the contract differentiate between critical and non-critical path delays for enforcement?\n"
            "5. Can liquidated damages be enforced alongside actual damages, or are they exclusive remedies?"
        )
    },
    {
        "role": "user",
        "content": "When is payment due to the contractor?"
    },
    {
        "role": "assistant",
        "content": (
            "1. What is the standard payment cycle defined in the contract (e.g., net 30)?\n"
            "2. Are payment deadlines tied to approval of pay applications or milestones?"
        )
    },
    {
        "role": "user",
        "content": "How is substantial completion defined?"
    },
    {
        "role": "assistant",
        "content": (
            "1. Does substantial completion include readiness for occupancy, or just operational capability?\n"
            "2. Who certifies substantial completion and what documentation is required?\n"
            "3. Are there any milestone payment releases or retention tied to achieving substantial completion?\n"
            "4. What contractual obligations shift at the point of substantial completion (e.g., risk of loss, warranties)?"
        )
    },
    {
        "role": "user",
        "content": "When is the contractor entitled to release of retention?"
    },
    {
        "role": "assistant",
        "content": (
            "1. What milestones or deliverables must be met for retention release?\n"
            "2. Is a certificate of final completion required before final payment?\n"
            "3. Are there any contractual delays permitted in the release of retention?\n"
            "4. Is partial retention release available before final completion under specific conditions?"
        )
    }
]
fewshotDirectSubquery2 = [
    {
        "role": "user",
        "content": "What are the liquidated damages under the contract?"
    },
    {
        "role": "assistant",
        "content": (
            "1. Under which conditions does the contract trigger liquidated damages?\n"
            "2. How is the daily rate for delay damages calculated and justified?\n"
            "3. What exceptions or grace periods exist that can waive or reduce liquidated damages?\n"
            "4. How are critical path delays distinguished from non-critical delays for applying penalties?\n"
            "5. Can the contractor offset liquidated damages against actual losses or other remedies?"
        )
    },
    {
        "role": "user",
        "content": "When is payment due to the contractor?"
    },
    {
        "role": "assistant",
        "content": (
            "1. What events or deliverables trigger the start of the payment timeline?\n"
            "2. Which party’s approval is required before payments become due?\n"
            "3. What is the defined payment period once the invoice is approved?\n"
            "4. Are there conditional holds or retainage that delay payment under certain circumstances?"
        )
    },
    {
        "role": "user",
        "content": "How is substantial completion defined?"
    },
    {
        "role": "assistant",
        "content": (
            "1. What criteria or deliverables mark the milestone for substantial completion?\n"
            "2. Who certifies substantial completion and what documentation is required?\n"
            "3. What contractual obligations and risk shifts occur upon achieving substantial completion?\n"
            "4. Are there financial releases or warranty transitions tied to substantial completion?"
        )
    },
    {
        "role": "user",
        "content": "When is the contractor entitled to release of retention?"
    },
    {
        "role": "assistant",
        "content": (
            "1. What conditions or milestones must be satisfied to trigger retention release?\n"
            "2. Is a formal certification or inspection required before retention is released?\n"
            "3. How does the contract address partial retention releases before final completion?\n"
            "4. Under what circumstances can the client delay or withhold retention release?"
        )
    }
]


def plan_subquery2(model: str, query: str) -> dict:
    msgs = [
        {"role": "system", "content": altSubquerySys},
        *fewshotDirectSubquery2,
        {"role": "user", "content": query},
    ]
    response = chat(model, msgs)

    # Extract numbered list into array
    subqueries = [
        line.strip().split(". ", 1)[1]
        for line in response.strip().splitlines()
        if re.match(r"^\d+\.\s", line)
    ]

    return {"subqueries": subqueries}


def missingInfo(model: str, query: str, generatedResponse: str) -> dict[str, Union[bool, list[str] | None]]:
    print("Missing info called with query:", query)
    
    msgs = [
        {"role": "system", "content": missingInfoSys},
        {
            "role": "user",
            "content": json.dumps({
                "query": query,
                "generatedResponse": generatedResponse
            })
        },
    ]

    response = chat(model, msgs).strip()
    print("Response from missingInfo:", response)

    if response.strip().lower() == "assessment: sufficient":
        return {"sufficient": True, "missingInfo": None}

    # Extract subqueries from numbered list
    subqueries = []
    for line in response.splitlines():
        m = re.match(r"^\s*\d+\.\s+(.*)$", line)
        if m:
            subqueries.append(m.group(1).strip())

    return {"sufficient": False, "missingInfo": subqueries}
    


def chat(model: str, messages: list) -> str:
    return ollama.chat(
        model=model, messages=messages, options={"temperature": 0}, think=False
    )["message"]["content"].strip()


def decompose(model: str, prompt: str):
    msgs = [
        {"role": "system", "content": decompSys},
        *fewshotDecomp,
        {"role": "user", "content": prompt},
    ]
    raw = chat("qwen3:4b", msgs)
    try:
        return json.loads(raw)
    except json.JSONDecodeError:
        return None


def extract_keywords(model: str, query: str) -> str:
    msgs = [
        {"role": "system", "content": keywordSys},
        *fewshotKeyword,
        {"role": "user", "content": query},
    ]
    return chat(model, msgs)


def plan_subqueries(model: str, kw_json: str) -> str:
    msgs = [
        {"role": "system", "content": subquerySys},
        *fewshotSubquery,
        {"role": "user", "content": kw_json},
    ]
    return chat(model, msgs)


def md_row(*cells):
    return "| " + " | ".join(c.replace("|", "\\|") for c in cells) + " |"


def print_per_prompt(prompt: str, decomp: dict):
    print(md_row(prompt, "context", "; ".join(decomp.get("context", []))))
    for q in decomp.get("queries", []):
        print(md_row(prompt, "query", q))
    for d in decomp.get("directives", []):
        print(md_row(prompt, "directive", d))
    for n in decomp.get("noise", []):
        print(md_row(prompt, "noise", n))

def fullAgents(model: str, prompt: str):
    keywords, subqueries = [],[]
    decomp = decompose(model,prompt)
    if decomp and decomp.get("queries"):
            for q in decomp["queries"]:
                keyword = extract_keywords(model, q)
                subq = plan_subqueries(model, keyword)
                keywords.append((q, keyword))
                subqueries.append((q, subq))

    return keywords, subqueries 

    


def main(argv):
    if len(argv) != 2:
        sys.exit(1)

    model_name, path = argv
    with open(path) as fh:
        prompts_data = json.load(fh)

    subqueries = []
    truth, preds, decomp_json, kw_outputs, sub_outputs = [], [], [], [], []
    print("| Query | Subquery |")
    print("|---|---|")

    for item in prompts_data:
        prompt = item["prompt"]
        ground_truth = 1 if item.get("value") else 0

        decomp = decompose(model_name, prompt)
        decomp_json.append((prompt, decomp))

        is_query = 1 if decomp and decomp.get("queries") else 0
        preds.append(is_query)
        truth.append(ground_truth)

        if decomp and decomp.get("queries"):
            for q in decomp["queries"]:
                kw_json = extract_keywords(model_name, q)
                subq = plan_subqueries(model_name, kw_json)
                subquery = plan_subquery2(model_name, q)

                subqueries.append(subquery)
                kw_outputs.append((q, kw_json))
                sub_outputs.append((q, subq))
                print(f"| {q} | {subquery} |")




if __name__ == "__main__":
    main(sys.argv[1:])
